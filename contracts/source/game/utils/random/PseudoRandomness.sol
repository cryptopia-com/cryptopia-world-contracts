// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";

/// @title Pseudo-Random Base Contract
/// @dev Provides basic pseudo-random number generation capabilities using blockhash, sender address, 
/// and an internal seed. This is intended to be inherited by other contracts that require pseudo-random functionality
/// @notice It's important to understand that this method of generating randomness is predictable and can be influenced 
/// by miners to some extent. Therefore, it's intended to use this only in scenarios where the stakes are low and the 
/// potential benefit for a miner to manipulate the outcome is minimal
/// @author Frank Bonnet - <frankbonnet@outlook.com>
abstract contract PseudoRandomness is ContextUpgradeable 
{
    /**
     * Storage
     */
    /// @dev Represents a precision factor used for scaling random numbers. 
    /// This constant determines the range of possible values generated by the pseudo-random functions.
    uint constant public RANDOMNESS_PRECISION_FACTOR = 10_000; 


    /// @dev Pseudo random seed 
    bytes32 internal currentRandomSeed;


    /// @dev Initializes the pseudo randomness
    function __PseudoRandomness_init() 
        internal 
        onlyInitializing 
    {
        __Context_init();
        __PseudoRandomness_init_unchained();
    }


    /// @dev Initializes the pseudo randomness
    function __PseudoRandomness_init_unchained() 
        internal 
        onlyInitializing {
    }


    /**
     * Internal functions
     */
    /// @dev Pseudo-random hash generator
    /// @notice This is not secure, but it's good enough for our use case
    /// @return bytes32 Random hash
    function _generateRandomSeed() 
        internal 
        returns(bytes32) 
    {
        currentRandomSeed = keccak256(
            abi.encodePacked(blockhash(block.number - 1), 
            _msgSender(), 
            currentRandomSeed));
        return currentRandomSeed;
    }


    /// @dev Get a number between 0 (inlcuding) and RANDOMNESS_PRECISION_FACTOR from `_hash` at `index`
    /// @param _hash Pseudo randomly generated hash 
    /// @param index Used as salt
    /// @return uint Pseudo random number
    function _getRandomNumberAt(bytes32 _hash, uint index) 
        internal pure 
        returns(uint) 
    {
        return uint(keccak256(abi.encodePacked(_hash, index))) % RANDOMNESS_PRECISION_FACTOR;
    }


    /// @dev Get two numbers between 0 (inlcuding) and RANDOMNESS_PRECISION_FACTOR from `_hash` at `index1` and `index2`
    /// @param _hash Pseudo randomly generated hash
    /// @param index1 Used as salt
    /// @param index2 Used as salt
    /// @return value1 Pseudo random number
    /// @return value2 Pseudo random number
    function _getRandomNumberPairAt(bytes32 _hash, uint index1, uint index2) 
        internal pure 
        returns (uint value1, uint value2)
    {
        value1 = _getRandomNumberAt(_hash, index1);
        value2 = _getRandomNumberAt(_hash, index2);
    }
}